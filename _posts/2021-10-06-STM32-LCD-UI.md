---
title: STM32 LCD User Interface
date: 2021-10-06 08:00:00
layout: page
published: true
---

## Flexible UI User Interface
My last few blog posts are relatively dry discussions of hardware drivers, and this is where they come together! The LCD is perfect for providing feedback to the user and allowing for custom control of a lot of the underlying parameters. There are many options that can be exposed to the user, and this was the most expedient way of doing so.

### Expanding on the LCD Drivers
Aside from writing simple text to the screen using blocking I2C transmission, the LCD needs a few more features before we can use it in tandem with the realtime audio processing code that makes up the backbone of the system. Firstly, adding support for moving the write cursor around on the screen and writing whole strings needed to be added. Additionally, the screen updates must occur in sequential order to prevent writing unintelligible text. This is fairly simple, and using a singleton design pattern streamlines the process. A single instance of the LCD driver class ensures that it can effectively track the state of the screen during runtime, and prevents issues with multiple instances attempting to control a single hardware resource. Otherwise, there are very few additions that need to be made in order to interface the existing code with the additions mentioned in this blog post.

### Adding an Encoder
Now, aside from incorporating the LCD to provide feedback to the user, there needs to be some way for the user to interact with the system. For this, I decided to use a 24-detent continuous encoder with a pushbutton. This allows for scrolling through menus and a button for selecting various items in a relatively easy-to-control package. Since the LCD I am using is only 2 lines, the user interface is fairly constrained overall. 

The STM32 chip I selected has a ton of nice hardware features, which includes more advanced timer peripherals having built-in support for quatrature oscillators. Upon configuring this timer and wiring in the encoder, it works pretty well! There are some issues with overcounting due to the clock setting, but it was fairly simple to track the relative position of the encoder over the runtime of the system. The pushbutton component is just a simple GPIO input, making this a very low-cost way of adding user control to my software.

### Using the SysTick Scheduler
As mentioned in my last post, the blocking I2C transmissions to write to the screen take valuable processing time up for very little computational value. Thus, integrating screen updates with the scheduler I have written seems to be the best way to reduce the amount of time writing whole strings to the screen. Now, sequential I2C commands will be scheduled and executed on a fixed millisecond-basis with a low timeout value, meaning that operations will be performed throughout the runtime rather than in fixed, lengthy blocks. This reduces the audio interruptions in the system and overall provides a more robust way of writing to the LCD while preserving its state. Both the LCD and encoder drivers now operate on a fixed timeframe, controlled by the scheduler.

Each task enqueued will perform a simple hardware operation (clearing the screen, moving the write position, writing a single character, etc.) and then be destroyed. Since the scheduler maintains the ordering of these operations, no other tracking of screen state needs to be implemented, since the underlying drivers will handle the vast majority of these operations without any additional intervention. 

### Input & UI Updates
To make the UI accessible to the user, there needs to be a way to track screen position, current parameter values, and execute customizable behavior from the UI handler's context. To this effect, the UI handler provides a wrapper for all user interaction on top of the existing hardware drivers. 

The scheme is fairly simple. Each row of the menu is represented by a struct, shown in the code block below.

```
typedef struct mUI_TableRow {
	std::string rowText;
	uint16_t currValue;
	uint16_t maxValue;
	uint16_t minValue;
	uint8_t updateRate;
	uint8_t numPos;
	RowType_t rowType;
	void (*updateCallback)(void*);
	uint8_t args[7];
} UI_TableRow_t;
```

As shown, there are a few fields that control the behavior for each menu item. Since the function pointer takes a void pointer argument, we can allow the various functions to have a uniform interface for argument passing of various types. A common example is passing an object pointer as an argument, and then allowing the user to modify a parameter at will. Using modern C++, we have access to lambdas, which are incredibly useful for this purpose. All other information is used to control the integer parameters for each row, and the rules for its update. The ```rowType``` field is used to provide additional options, such as providing a way to enter submenus and toggle various boolean options.

The rows are collected into a table for each screen, with each object having a table for its own parameters. This means all parameter values and menu states are preserved for the correllated object for its entire lifetime in memory, meaning it is persistent. An example table is shown in the code block below.

```
static UI_TableRow_t voiceOptions[VOICE_OPTIONS_SIZE] {
		{"<-",				0,	0,	0,	0,		3,		RowType_t::SELECTOR, back_cb, 				{0}},
		{"Karplus-Strong", 	1, 	5, 	5,	0, 		15, 	RowType_t::SELECTOR, karplusStrongSel_cb, 	{0}},
		{"Wavetable", 		2, 	5, 	5,	0, 		10, 	RowType_t::SELECTOR, wavetableSel_cb, 		{0}},
		{"Noise",			3,  5,  5,  0, 		6, 		RowType_t::SELECTOR, noiseSel_cb,			{0}},
		{"FX Chain",		4,  5,  5,  0,      7,      RowType_t::SELECTOR, fxSel_cb,				{0}},
};
```

As shown, each table is of fixed size and a clean copy is stored for each class. The master table is immutable, and can be easily copied for each instance of a constructed class. In this case, all rows are of the ```SELECTOR``` type, and their callbacks open the various menus for each of the different options. The back arrow navigates to the previous submenu. This system is quite flexible and works quite well in practice, as the various items in the table (and their associated function pointers) can be configured for a huge variety of tasks. An example of how this screen is drawn to the LCD is shown below. The first code block shows the UI with only two lines, while the second shows how the screen would look for an N-row display.

```
<-
Karplus-Strong
Wavetable
```

```
<-
Karplus-Strong
Wavetable
Noise
FX Chain
```

To support submenus, a stack is used, where the top of the stack is the current submenu being written to the screen. When a submenu is opened, a new item is pushed onto the stack and drawn on the LCD. When a submenu is closed, it is popped off the stack and the previous menu is drawn on the LCD. This provides a robust system for tracking positions in the various submenus, and works fairly well. The current limit on submenu depth is 10, as to prevent significant wastes of memory space and to limit the user's ability to get lost in subemenus. Every submenu also contains a row to navigate to the previous menu on the stack, meaning it is fairly easy to navigate with just a simple encoder. 

Finally, there are a few nice-to-haves that allow the user to fully understand the state of the UI. The first is that a selected line will have a small karat (```>```) drawn next to it when selected. This tracks row position. If a row is selected, and it does not have ```RowType_t::SELECTOR``` as its row type, a star will appear in the place of the karat. This locks the scroll position on the screen so the encoder can be used to scroll through the various parameter values. An example of this control flow is shown below. 

1. The user hovers over the second line.

```
<- 
>Option 1:           0
Option 2:            0
```

2. The user presses the encoder's pushbutton, selecting the row.
```
<- 
*Option 1:          0
Option 2:            0
```

3. The user turns the encoder knob, changing the parameter value.
```
<- 
*Option 1:           5
Option 2:            0
```
4. The user deselects the second line, allowing navigation between the rows once more.
```
<- 
>Option 1:           5
Option 2:            0
```

It is worth noting that the update function pointer for the row is called either upon row selection, or the turning of the line while the row is selected. For the ```SELECTOR``` row type, the function pointer is invoked when selected, which is useful for boolean operations and menu navigation. For the ```COUNTER``` row type, the function pointer is invoked at a fixed rate when the encoder is turned to update its associated parameter value.

This scheme works fairly well, and provides a lot of flexibility in exposing the functionality of the system to the user. I'm very proud of how it turned out, and how well it functions as a very simple interface for user control.

### Wrapping Up
Given how verbose this post is, I plan to include a demo video when the system is closer to being completed! I realize that this is not the most ideal form for describing a predominantly visual system, so I apologize for that :). Overall, this system provides the framework for most of the user interaction with the system in a way that subverts a lot of the complexity of providing a system to build off of. There are a few more features I plan to implement (getting a larger LCD, implementing a few new row types, etc.), but I am very happy with the performance of this user interface so far.