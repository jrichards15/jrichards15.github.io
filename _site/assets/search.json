

[
  
  
    
    
      {
        "title": "Fun With Fractions",
        "excerpt": "A Simple Program to Prove Countability of Rationals\nThis was a small experiment to enumerate all rational numbers of form x/y\nutilizing a set of piecewise equations as a proof that rationals are countable. \nI programmed this in Ruby for ease of implementation. This includes a fraction class \nand simplification utilizing Euclid’s GCD algorithm. Some of the theoretical backing \ncame from StackExchange, and is cited in the readme for the project.\n\nThe theoretical backing relies on the use of a breadth-first traversal of the Calkin-Wilf\ntree utilizing Stern’s diatomic sequence to enumerate the rationals. An example Calkin-Wilf tree can be seen below (image from Wikipedia).\n\n\n\nThe nth rational is therfore generated using the definition of the fusc() function, with the rational generated as fusc(n)/fusc(n+1). As such, the sequence forms the numerator and denominator as specified by the Calkin-Wilf tree. The program can convert between both rational numbers and their associated labels via command-line arguments.\n\nThe project itself can be found here:\nFractions!\n",
        "content": "A Simple Program to Prove Countability of Rationals\nThis was a small experiment to enumerate all rational numbers of form x/y\nutilizing a set of piecewise equations as a proof that rationals are countable. \nI programmed this in Ruby for ease of implementation. This includes a fraction class \nand simplification utilizing Euclid’s GCD algorithm. Some of the theoretical backing \ncame from StackExchange, and is cited in the readme for the project.\n\nThe theoretical backing relies on the use of a breadth-first traversal of the Calkin-Wilf\ntree utilizing Stern’s diatomic sequence to enumerate the rationals. An example Calkin-Wilf tree can be seen below (image from Wikipedia).\n\n\n\nThe nth rational is therfore generated using the definition of the fusc() function, with the rational generated as fusc(n)/fusc(n+1). As such, the sequence forms the numerator and denominator as specified by the Calkin-Wilf tree. The program can convert between both rational numbers and their associated labels via command-line arguments.\n\nThe project itself can be found here:\nFractions!\n",
        "url": "/2020/06/13/FUN-WITH-FRACTIONS/"
      },
    
      {
        "title": "L-System Fractal Generator",
        "excerpt": "Using L-System Grammars to Represent Recursive Patterns\nL-System Description\nEssentially, this program generate strings that adhere to forms dictated by a specified grammar. As a slight (and perhaps inaccurate) brief on l-systems:\n\nL-systems are described as a 3-tuple: G = (V, omega, P). V represents the alphabet, or set of symbols containing all terminals and nonterminals utilized in the grammar. Omega is the starting point for the L-system, which is iterated over to produce the result. Finally, P is the set of rules (productions) that dictate how the system will behave given the number of symbols. A system with one production per non-terminal is deterministic, as it has a set outcome for all iterations. The code in this repo supports both deterministic and non-deterministic (stochastic) systems. See here for more information on L-systems.\n\nLsystems.py Overview\nThis project began as a simple exploration into the PyCairo graphics library and practice with simple Python operations. The core generation of the l-systems utilizes an iterative approach to replace the string character-by-character with their predefined replacement.\n\nFor this project, the production rules were handled by classes LProduction and LProbabilisticProduction, which both contain the rules for a specified non-terminal. The primary difference is the P field. For the standard production, this is merely a string literal. However, for the stochastic representation, this is represented as a sorted list of 2-tuples, containing a string literal and a floating point value in order to represent the probability of a given production being selected.\n\nThe systems themselves contain functions to check the given alphabet, find the production rules for a given nonterminal in said alphabet, and step the given axiom forward one iteration. They are relatively straightforward to operate and produce decent results. It is worth noting that the strings they operate on grow exponentially, leading to significant slowdowns for larger numbers of iterations.\n\nThe GitHub repo for this project can be found here.\n\nDraw.py Overview\nAs a bonus, I decided to render the results of the l-system generation utilizing the PyCairo module, which provided a robust framework for drawing each figure. There are a few classes contained within this file.\n\nThe DrawSystem class provides a subclass for the previously-discussed LSystem class, which allows it to operate upon the same data model while adding functionality. It utilizes the superclass attributes to generate the L-system to be drawn, then utilizes the PyCairo library to render them. It also takes in parameters for line thickness, length, and image dimensions. As such, they are fully configurable. The number of iteration the l-system will be run for is also specified. Finally, it takes in a list of production rules to specify how each character be represented graphically.\n\nThe DrawProduction class is used to represent these production rules, with each character in the alphabet corresponding to a certain operation. Since the images are rendered utilizing a custom-programmed turtle, each character can take a certain operation, defined in the InstructionEnum class, which specifies all supported operations for the turtle. The turtle code is contained within the ProductionTurtle class, which tracks its (x,y) position and its current angle. It also contains the rules for each instruction in the InstructionEnum, and interprets them into PyCairo operations.\n\nFinally, the ShaderTracker class is a bit vestigial, as I have decided to leave it somewhat unfinished. As it currently stands, it takes in a list of hex color code values and converts them to RGB values (limited between float values 0.0 and 1.0 instead of 0 and 255), then keeps track of the current brush color until the next time next_color() is called. It is employed in a few of the DrawSystem functions, including draw_color(...) and draw_subtractive_color(...).\n\nDrawing results in the creation of a results directory and a .png file. The images are black-and-white and contain the centered rendering of the given l-system. There is support for drawing multiple iterations of the same l-system in the function draw_multiple(). I am working on colorizing these images, though I’m losing interest in the project and will pick it up again in a few weeks. The color functions rely on overlaying multiple iterations in order to show progression, though this sometimes results in blur and unsightly overlap. I attempted to address this in draw_subtractive_color to mixed results, which I will eventually go back and fix.\n\nAs of the current version, only the deterministic L-systems are supported due to the inheritance of the LSystem class rather than the ProbabilisticLSystem class. Perhaps I will go back and include a fix for this in the next version. For now, I have decided to leave it as-is.\n\nExample Outputs\nHere are a few examples of the results:\n\n\n\n",
        "content": "Using L-System Grammars to Represent Recursive Patterns\nL-System Description\nEssentially, this program generate strings that adhere to forms dictated by a specified grammar. As a slight (and perhaps inaccurate) brief on l-systems:\n\nL-systems are described as a 3-tuple: G = (V, omega, P). V represents the alphabet, or set of symbols containing all terminals and nonterminals utilized in the grammar. Omega is the starting point for the L-system, which is iterated over to produce the result. Finally, P is the set of rules (productions) that dictate how the system will behave given the number of symbols. A system with one production per non-terminal is deterministic, as it has a set outcome for all iterations. The code in this repo supports both deterministic and non-deterministic (stochastic) systems. See here for more information on L-systems.\n\nLsystems.py Overview\nThis project began as a simple exploration into the PyCairo graphics library and practice with simple Python operations. The core generation of the l-systems utilizes an iterative approach to replace the string character-by-character with their predefined replacement.\n\nFor this project, the production rules were handled by classes LProduction and LProbabilisticProduction, which both contain the rules for a specified non-terminal. The primary difference is the P field. For the standard production, this is merely a string literal. However, for the stochastic representation, this is represented as a sorted list of 2-tuples, containing a string literal and a floating point value in order to represent the probability of a given production being selected.\n\nThe systems themselves contain functions to check the given alphabet, find the production rules for a given nonterminal in said alphabet, and step the given axiom forward one iteration. They are relatively straightforward to operate and produce decent results. It is worth noting that the strings they operate on grow exponentially, leading to significant slowdowns for larger numbers of iterations.\n\nThe GitHub repo for this project can be found here.\n\nDraw.py Overview\nAs a bonus, I decided to render the results of the l-system generation utilizing the PyCairo module, which provided a robust framework for drawing each figure. There are a few classes contained within this file.\n\nThe DrawSystem class provides a subclass for the previously-discussed LSystem class, which allows it to operate upon the same data model while adding functionality. It utilizes the superclass attributes to generate the L-system to be drawn, then utilizes the PyCairo library to render them. It also takes in parameters for line thickness, length, and image dimensions. As such, they are fully configurable. The number of iteration the l-system will be run for is also specified. Finally, it takes in a list of production rules to specify how each character be represented graphically.\n\nThe DrawProduction class is used to represent these production rules, with each character in the alphabet corresponding to a certain operation. Since the images are rendered utilizing a custom-programmed turtle, each character can take a certain operation, defined in the InstructionEnum class, which specifies all supported operations for the turtle. The turtle code is contained within the ProductionTurtle class, which tracks its (x,y) position and its current angle. It also contains the rules for each instruction in the InstructionEnum, and interprets them into PyCairo operations.\n\nFinally, the ShaderTracker class is a bit vestigial, as I have decided to leave it somewhat unfinished. As it currently stands, it takes in a list of hex color code values and converts them to RGB values (limited between float values 0.0 and 1.0 instead of 0 and 255), then keeps track of the current brush color until the next time next_color() is called. It is employed in a few of the DrawSystem functions, including draw_color(...) and draw_subtractive_color(...).\n\nDrawing results in the creation of a results directory and a .png file. The images are black-and-white and contain the centered rendering of the given l-system. There is support for drawing multiple iterations of the same l-system in the function draw_multiple(). I am working on colorizing these images, though I’m losing interest in the project and will pick it up again in a few weeks. The color functions rely on overlaying multiple iterations in order to show progression, though this sometimes results in blur and unsightly overlap. I attempted to address this in draw_subtractive_color to mixed results, which I will eventually go back and fix.\n\nAs of the current version, only the deterministic L-systems are supported due to the inheritance of the LSystem class rather than the ProbabilisticLSystem class. Perhaps I will go back and include a fix for this in the next version. For now, I have decided to leave it as-is.\n\nExample Outputs\nHere are a few examples of the results:\n\n\n\n",
        "url": "/2020/07/17/LSYSTEM-FRACTALS/"
      },
    
  
  
  
  {
    "title": "Categories",
    "excerpt": "Category index\n",
    "content": "\n",
    "url": "/categories/"
  },
  
  {
    "title": "Blog",
    "excerpt": "\n",
    "content": "\n",
    "url": "/blog/"
  },
  
  {
    "title": "Jack Richards",
    "excerpt": "\n",
    "content": "Computer Engineering Senior @ UMD\nI’m a computer engineering senior with interest in embedded computing and audio processing. This website is a showcase of all my small projects, some interesting and some noticeably less so.\n\nFor projects and general notes, see the Blog section for more information. This page contains all posts pertaining to my personal interests. For a synopsis of my work experience and academics, see Resume. For an archive and description of my radio broadcasts, see Radio.\n\nOngoing Projects (without Blog posts)\n\n  Modular Synthesizer (fabrication &amp; design), with the end goal of producing a DIY performance-ready musical instrument.\n    \n      Currently building Mutable Instruments Plaits, Veils, and Ripples. See here for more information on the modules. Open-source information can be found on Emilie Gillet’s GitHub.\n      Currently designing a sampler based on an obsolete answering machine IC and an input module to convert line levels to be compatible with standard Eurorack levels.\n    \n  \n  Lyrics Checker utilizing Spotify Web API, used to filter explicit music according to FCC decency guidelines.\n\n",
    "url": "/"
  },
  
  {
    "title": "Radio Show",
    "excerpt": "\n",
    "content": "Point of Failure\nI’m a DJ for UMD’s on-campus, student-run radio station! I broadcast all semester long. \nFor more information on UMD’s radio station, see WMUC’s official website here. My show is \nonce-weekly for an hour. Below is an archive of all previous broadcasts, both on WMUC’s digital (streaming) and FM (88.1) \nstation.\n\nWMUC FM (Spring ‘20)\n\n  March 6th, 2020\nSpotify Playlist / \nShow\n  February 28th, 2020\nSpotify Playlist\nShow\n  February 21st 2020\nSpotify Playlist / \nShow\n  February 14th, 2020\nSpotify Playlist / \nShow\n  February 7th, 2020\nSpotify Playlist / \nShow\n  January 31st, 2020\nSpotify Playlist / \nShow\n\n\nWMUC Digital (Fall ‘19)\n\n  December 6th, 2019\nSpotify Playlist / \nShow\n  November 29th, 2019\nSpotify Playlist / \nShow\n  November 22nd, 2019\nSpotify Playlist / \nShow\n  November 15th, 2019\nSpotify Playlist / \nShow\n  November 8th, 2019  \nSpotify Playlist / \nShow\n  November 1st, 2019\nSpotify Playlist / \nShow\n\n",
    "url": "/radio/"
  },
  
  {
    "title": "Resume",
    "excerpt": "\n",
    "content": "A PDF version of this page is available here.\nLast updated: June 14th, 2020\n\nEducation\n\nUniversity of Maryland, College Park | Clark School of Engineering (Expected May 2021)\n\n  BS, Computer Engineering; Cumulative GPA: 3.9\n  Courses: Computer Architecture, Compilers, Algorithms, Digital Logic Design, Computer Architecture, Signals &amp; System Theory, Analog and Digital Electronics, Organization of Programming Languages, and Introduction to Computer Systems\n\n\nWork Experience\n\nResearch Support Instruments | Software Engineering Intern (May 2019 - Present)\n\n  Implemented and tested the flight software for an onboard instrument packaged designed for consumer-grade quadcopters.\n  Utilized an Arduino Nano and an embedded device to transfer data remotely with a ground station, allowing for scientifically significant data collection with a +/-3% error threshold.\n\n\nUMD Department of Computer Science | Teaching Assistant (Jan. 2020 - May 2020)\n\n  Tutored students in office hours on OCaml, Ruby, and general programming language concepts.\n  Assisted in the creation of course materials alongside 30 other undergraduate teaching assistants for CMSC330.\n\n\nSalem Art Association | Logistics Intern (Jun 2018. - Jul. 2018)\n\n  Volunteer coordinator of thirty people collecting trash, recycling, and composed over the course of a three-day festival hosting 30,000 people.\n  Compiled a formal report on the establishment of a paperless ticketing system at each of the entrances to reduce wait times.\n\n\nWinquest Engineering Corporation | Cybersecurity Intern (Jun. 2016 - Aug. 2016)\n\n  Achieved a 60% increase in successful security tests by designing a program to teach good security practices.\n  Assisted comprehensive security testing of commercial networks utilizing Linux and associated tools.\n  Researched the theory and methods behind penetration testing and cybersecurity.\n\n\nTechnical Projects\n\nUniversity of Maryland Keystone | Project Lead\n\n  Designed an autonomous rover for a fire suppression mission that moved debris and extinguised fire\n  Utilized the Arduino microcontroller for prototyping and controlling navigation and manipulation\n  Presented a formal design report with visual aids to thirty-person audience\n\n\nProcedural Maze Project | Programming Lead\n\n  Utilized cellular automata and Perlin noise in the Unity3D engine to generate random patterns and mazes.\n\n\nLeadership\n\nVirtus at University of Maryland | Mentor (Aug. 2017 - May 2018)\n\n  Participate in seminars on pre-professional development and engineering design.\n\n\nCyberPatriot | Team Leader (Aug. 2015 - May 2017)\n\n  Searched for and remedied vulnerabilities ina virtual Windows environment\n  Met weekly for practice and competed in the Maryland regional Platinum division.\n\n\nTechnical Skills\n\n  Java\n  C/C++/C#\n  Arduino\n  Python\n  MATLAB\n  LaTeX\n  Linux\n  OCaml\n  Racket\n  Ruby\n\n",
    "url": "/resume/"
  }
  
]

