<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-17T17:34:57-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">A (Mostly Empty) Student Portfolio</title><subtitle>Welcome! This is a showcase of all of my work thus far. It consists primarily of personal projects and other interesting (I hope!) tidbits. All student work isn't allowed to be shared, hence the somewhat empty website.</subtitle><author><name>Jack Richards</name></author><entry><title type="html">L-System Fractal Generator</title><link href="http://localhost:4000/2020/07/17/LSYSTEM-FRACTALS/" rel="alternate" type="text/html" title="L-System Fractal Generator" /><published>2020-07-17T01:00:00-04:00</published><updated>2020-07-17T01:00:00-04:00</updated><id>http://localhost:4000/2020/07/17/LSYSTEM-FRACTALS</id><content type="html" xml:base="http://localhost:4000/2020/07/17/LSYSTEM-FRACTALS/">&lt;h2 id=&quot;using-l-system-grammars-to-represent-recursive-patterns&quot;&gt;Using L-System Grammars to Represent Recursive Patterns&lt;/h2&gt;
&lt;h3 id=&quot;l-system-description&quot;&gt;L-System Description&lt;/h3&gt;
&lt;p&gt;Essentially, this program generate strings that adhere to forms dictated by a specified grammar. As a slight (and perhaps inaccurate) brief on l-systems:&lt;/p&gt;

&lt;p&gt;L-systems are described as a 3-tuple: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G = (V, omega, P)&lt;/code&gt;. &lt;strong&gt;V&lt;/strong&gt; represents the alphabet, or set of symbols containing all terminals and nonterminals utilized in the grammar. &lt;strong&gt;Omega&lt;/strong&gt; is the starting point for the L-system, which is iterated over to produce the result. Finally, &lt;strong&gt;P&lt;/strong&gt; is the set of rules (productions) that dictate how the system will behave given the number of symbols. A system with one production per non-terminal is deterministic, as it has a set outcome for all iterations. The code in this repo supports both deterministic and non-deterministic (stochastic) systems. See &lt;a href=&quot;https://en.wikipedia.org/wiki/L-system&quot;&gt;here&lt;/a&gt; for more information on L-systems.&lt;/p&gt;

&lt;h3 id=&quot;lsystemspy-overview&quot;&gt;Lsystems.py Overview&lt;/h3&gt;
&lt;p&gt;This project began as a simple exploration into the PyCairo graphics library and practice with simple Python operations. The core generation of the l-systems utilizes an iterative approach to replace the string character-by-character with their predefined replacement.&lt;/p&gt;

&lt;p&gt;For this project, the production rules were handled by classes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LProduction&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LProbabilisticProduction&lt;/code&gt;, which both contain the rules for a specified non-terminal. The primary difference is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; field. For the standard production, this is merely a string literal. However, for the stochastic representation, this is represented as a sorted list of 2-tuples, containing a string literal and a floating point value in order to represent the probability of a given production being selected.&lt;/p&gt;

&lt;p&gt;The systems themselves contain functions to check the given alphabet, find the production rules for a given nonterminal in said alphabet, and step the given axiom forward one iteration. They are relatively straightforward to operate and produce decent results. It is worth noting that the strings they operate on grow exponentially, leading to significant slowdowns for larger numbers of iterations.&lt;/p&gt;

&lt;p&gt;The GitHub repo for this project can be found &lt;a href=&quot;https://github.com/jrichards15/lsystems-python&quot;&gt;here.&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;drawpy-overview&quot;&gt;Draw.py Overview&lt;/h3&gt;
&lt;p&gt;As a bonus, I decided to render the results of the l-system generation utilizing the PyCairo module, which provided a robust framework for drawing each figure. There are a few classes contained within this file.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DrawSystem&lt;/code&gt; class provides a subclass for the previously-discussed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LSystem&lt;/code&gt; class, which allows it to operate upon the same data model while adding functionality. It utilizes the superclass attributes to generate the L-system to be drawn, then utilizes the PyCairo library to render them. It also takes in parameters for line thickness, length, and image dimensions. As such, they are fully configurable. The number of iteration the l-system will be run for is also specified. Finally, it takes in a list of production rules to specify how each character be represented graphically.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DrawProduction&lt;/code&gt; class is used to represent these production rules, with each character in the alphabet corresponding to a certain operation. Since the images are rendered utilizing a custom-programmed turtle, each character can take a certain operation, defined in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstructionEnum&lt;/code&gt; class, which specifies all supported operations for the turtle. The turtle code is contained within the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProductionTurtle&lt;/code&gt; class, which tracks its (x,y) position and its current angle. It also contains the rules for each instruction in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstructionEnum&lt;/code&gt;, and interprets them into PyCairo operations.&lt;/p&gt;

&lt;p&gt;Finally, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ShaderTracker&lt;/code&gt; class is a bit vestigial, as I have decided to leave it somewhat unfinished. As it currently stands, it takes in a list of hex color code values and converts them to RGB values (limited between float values 0.0 and 1.0 instead of 0 and 255), then keeps track of the current brush color until the next time &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next_color()&lt;/code&gt; is called. It is employed in a few of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DrawSystem&lt;/code&gt; functions, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw_color(...)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw_subtractive_color(...)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Drawing results in the creation of a results directory and a .png file. The images are black-and-white and contain the centered rendering of the given l-system. There is support for drawing multiple iterations of the same l-system in the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw_multiple()&lt;/code&gt;. I am working on colorizing these images, though Iâ€™m losing interest in the project and will pick it up again in a few weeks. The color functions rely on overlaying multiple iterations in order to show progression, though this sometimes results in blur and unsightly overlap. I attempted to address this in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw_subtractive_color&lt;/code&gt; to mixed results, which I will eventually go back and fix.&lt;/p&gt;

&lt;p&gt;As of the current version, only the deterministic L-systems are supported due to the inheritance of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LSystem&lt;/code&gt; class rather than the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ProbabilisticLSystem&lt;/code&gt; class. Perhaps I will go back and include a fix for this in the next version. For now, I have decided to leave it as-is.&lt;/p&gt;

&lt;h3 id=&quot;example-outputs&quot;&gt;Example Outputs&lt;/h3&gt;
&lt;p&gt;Here are a few examples of the results:
&lt;img src=&quot;/assets/img/dragoncurve.png&quot; alt=&quot;dragon-curve&quot; class=&quot;img-responsive&quot; /&gt;
&lt;img src=&quot;/assets/img/sierpinski.png&quot; alt=&quot;sierpinski-triangle&quot; class=&quot;img-responsive&quot; /&gt;
&lt;img src=&quot;/assets/img/arrowhead.png&quot; alt=&quot;arrowhead-curve&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;</content><author><name>Jack Richards</name></author><summary type="html">Using L-System Grammars to Represent Recursive Patterns L-System Description Essentially, this program generate strings that adhere to forms dictated by a specified grammar. As a slight (and perhaps inaccurate) brief on l-systems: L-systems are described as a 3-tuple: G = (V, omega, P). V represents the alphabet, or set of symbols containing all terminals and nonterminals utilized in the grammar. Omega is the starting point for the L-system, which is iterated over to produce the result. Finally, P is the set of rules (productions) that dictate how the system will behave given the number of symbols. A system with one production per non-terminal is deterministic, as it has a set outcome for all iterations. The code in this repo supports both deterministic and non-deterministic (stochastic) systems. See here for more information on L-systems. Lsystems.py Overview This project began as a simple exploration into the PyCairo graphics library and practice with simple Python operations. The core generation of the l-systems utilizes an iterative approach to replace the string character-by-character with their predefined replacement. For this project, the production rules were handled by classes LProduction and LProbabilisticProduction, which both contain the rules for a specified non-terminal. The primary difference is the P field. For the standard production, this is merely a string literal. However, for the stochastic representation, this is represented as a sorted list of 2-tuples, containing a string literal and a floating point value in order to represent the probability of a given production being selected. The systems themselves contain functions to check the given alphabet, find the production rules for a given nonterminal in said alphabet, and step the given axiom forward one iteration. They are relatively straightforward to operate and produce decent results. It is worth noting that the strings they operate on grow exponentially, leading to significant slowdowns for larger numbers of iterations. The GitHub repo for this project can be found here. Draw.py Overview As a bonus, I decided to render the results of the l-system generation utilizing the PyCairo module, which provided a robust framework for drawing each figure. There are a few classes contained within this file. The DrawSystem class provides a subclass for the previously-discussed LSystem class, which allows it to operate upon the same data model while adding functionality. It utilizes the superclass attributes to generate the L-system to be drawn, then utilizes the PyCairo library to render them. It also takes in parameters for line thickness, length, and image dimensions. As such, they are fully configurable. The number of iteration the l-system will be run for is also specified. Finally, it takes in a list of production rules to specify how each character be represented graphically. The DrawProduction class is used to represent these production rules, with each character in the alphabet corresponding to a certain operation. Since the images are rendered utilizing a custom-programmed turtle, each character can take a certain operation, defined in the InstructionEnum class, which specifies all supported operations for the turtle. The turtle code is contained within the ProductionTurtle class, which tracks its (x,y) position and its current angle. It also contains the rules for each instruction in the InstructionEnum, and interprets them into PyCairo operations. Finally, the ShaderTracker class is a bit vestigial, as I have decided to leave it somewhat unfinished. As it currently stands, it takes in a list of hex color code values and converts them to RGB values (limited between float values 0.0 and 1.0 instead of 0 and 255), then keeps track of the current brush color until the next time next_color() is called. It is employed in a few of the DrawSystem functions, including draw_color(...) and draw_subtractive_color(...). Drawing results in the creation of a results directory and a .png file. The images are black-and-white and contain the centered rendering of the given l-system. There is support for drawing multiple iterations of the same l-system in the function draw_multiple(). I am working on colorizing these images, though Iâ€™m losing interest in the project and will pick it up again in a few weeks. The color functions rely on overlaying multiple iterations in order to show progression, though this sometimes results in blur and unsightly overlap. I attempted to address this in draw_subtractive_color to mixed results, which I will eventually go back and fix. As of the current version, only the deterministic L-systems are supported due to the inheritance of the LSystem class rather than the ProbabilisticLSystem class. Perhaps I will go back and include a fix for this in the next version. For now, I have decided to leave it as-is. Example Outputs Here are a few examples of the results:</summary></entry><entry><title type="html">Fun With Fractions</title><link href="http://localhost:4000/2020/06/13/FUN-WITH-FRACTIONS/" rel="alternate" type="text/html" title="Fun With Fractions" /><published>2020-06-13T04:00:00-04:00</published><updated>2020-06-13T04:00:00-04:00</updated><id>http://localhost:4000/2020/06/13/FUN-WITH-FRACTIONS</id><content type="html" xml:base="http://localhost:4000/2020/06/13/FUN-WITH-FRACTIONS/">&lt;h3 id=&quot;a-simple-program-to-prove-countability-of-rationals&quot;&gt;A Simple Program to Prove Countability of Rationals&lt;/h3&gt;
&lt;p&gt;This was a small experiment to enumerate all rational numbers of form &lt;strong&gt;&lt;em&gt;x/y&lt;/em&gt;&lt;/strong&gt;
utilizing a set of piecewise equations as a proof that rationals are countable. 
I programmed this in Ruby for ease of implementation. This includes a fraction class 
and simplification utilizing Euclidâ€™s GCD algorithm. Some of the theoretical backing 
came from StackExchange, and is cited in the readme for the project.&lt;/p&gt;

&lt;p&gt;The theoretical backing relies on the use of a breadth-first traversal of the Calkin-Wilf
tree utilizing Sternâ€™s diatomic sequence to enumerate the rationals. An example Calkin-Wilf tree can be seen below (image from Wikipedia).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/6/62/Calkin-Wilf_tree.svg&quot; alt=&quot;calkin-wilf&quot; class=&quot;img-responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The nth rational is therfore generated using the definition of the &lt;strong&gt;fusc()&lt;/strong&gt; function, with the rational generated as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(n)/fusc(n+1)&lt;/code&gt;. As such, the sequence forms the numerator and denominator as specified by the Calkin-Wilf tree. The program can convert between both rational numbers and their associated labels via command-line arguments.&lt;/p&gt;

&lt;p&gt;The project itself can be found here:
&lt;a href=&quot;https://github.com/jrichards15/ruby-fractions&quot;&gt;Fractions!&lt;/a&gt;&lt;/p&gt;</content><author><name>Jack Richards</name></author><summary type="html">A Simple Program to Prove Countability of Rationals This was a small experiment to enumerate all rational numbers of form x/y utilizing a set of piecewise equations as a proof that rationals are countable. I programmed this in Ruby for ease of implementation. This includes a fraction class and simplification utilizing Euclidâ€™s GCD algorithm. Some of the theoretical backing came from StackExchange, and is cited in the readme for the project. The theoretical backing relies on the use of a breadth-first traversal of the Calkin-Wilf tree utilizing Sternâ€™s diatomic sequence to enumerate the rationals. An example Calkin-Wilf tree can be seen below (image from Wikipedia). The nth rational is therfore generated using the definition of the fusc() function, with the rational generated as fusc(n)/fusc(n+1). As such, the sequence forms the numerator and denominator as specified by the Calkin-Wilf tree. The program can convert between both rational numbers and their associated labels via command-line arguments. The project itself can be found here: Fractions!</summary></entry></feed>